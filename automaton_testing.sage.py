

# This file was *autogenerated* from the file automaton_testing.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2)
from traintrack import *
from sage.combinat.permutation import Permutations
import copy

from sage.graphs.views import EdgesView
from cusp import cusp
from itertools import product
from sage.combinat.permutation import Permutations
import copy
from check_dict_values_cyclic import *

from traintrack import *
from cusp import *
from sage.graphs.views import EdgesView
from itertools import product
from sage.combinat.permutation import Permutations
import copy
from check_dict_values_cyclic import *
from is_traintrack_in_list import *
from standardizing import *


G = Graph({_sage_const_0 :[_sage_const_0 ,_sage_const_1 ],_sage_const_1 :[_sage_const_0 ,_sage_const_1 ,_sage_const_2 ],_sage_const_2 :[_sage_const_1 ,_sage_const_2 ]})
order = {_sage_const_0 :[(_sage_const_0 ,_sage_const_1 ),(_sage_const_0 ,_sage_const_0 )],_sage_const_1 :[(_sage_const_1 ,_sage_const_2 ),(_sage_const_1 ,_sage_const_1 ),(_sage_const_0 ,_sage_const_1 )],_sage_const_2 :[(_sage_const_2 ,_sage_const_2 ),(_sage_const_1 ,_sage_const_2 )]}
infpoly = {"marked":[(_sage_const_1 ,[_sage_const_0 ]),(_sage_const_1 ,[_sage_const_1 ]),(_sage_const_1 ,[_sage_const_2 ])],"unmarked":[]}
singularity_type = {"marked":[_sage_const_1 ,_sage_const_1 ,_sage_const_1 ],"unmarked":[],"boundary":[_sage_const_1 ]}
c = cusp(_sage_const_1 ,((_sage_const_1 ,_sage_const_2 ),(_sage_const_0 ,_sage_const_1 )))
cusps_list = [c]
side_swapping_edges = [(_sage_const_0 ,_sage_const_0 ),(_sage_const_1 ,_sage_const_1 ),(_sage_const_2 ,_sage_const_2 )]

T = StandardTrainTrack(G,cusps_list, order, singularity_type, infpoly, side_swapping_edges)



# RIGHT_OVER_LEFT = 0
# LEFT_OVER_RIGHT = 1


AutomatonDict = {_sage_const_0 :T} 
AutomatonGraph = Graph({_sage_const_0 :[]}) #The automaton as a graph
AutomatonGraph.allow_multiple_edges(True)
AutomatonGraph.allow_loops(True)


list_of_tracks = [T] #list of train tracks, index of a traintrack is as specified by AutomatonDict

cusp_dictionary = {_sage_const_0 :cusps_list} #key is an integer, associated with a traintrack as specified by AutomatonDict


we_added_new_traintracks = True  # Start with True to enter the loop
number_of_traintrack_counter = _sage_const_0 

while we_added_new_traintracks == True:
    print("we added new tracks")
    we_added_new_traintracks = False  # Set to False initially, will be set to True if anything new is appended
    for j in list_of_tracks[number_of_traintrack_counter:]:
        for i in cusp_dictionary[list_of_tracks.index(j)]:
            print(f'i is {i} and j is {j}')
            print(f'we_added_new_traintracks is {we_added_new_traintracks}')
            index_of_cusp = _sage_const_0 
            T_ROL = j.deepcopy()
            # ROL_standardizing_braid = standardizing_braid(number_of_marked_points,T_ROL,i,0)
            T_ROL.fold(T_ROL.cusps[index_of_cusp], _sage_const_0 )
            T_LOR = j.deepcopy()
            # LOR_standardizing_braid = standardizing_braid(number_of_marked_points,T_LOR,i,1)
            T_LOR.fold(T_LOR.cusps[index_of_cusp], _sage_const_1 )

            if not is_traintrack_in_list(T_ROL, list_of_tracks)[_sage_const_0 ]:
                added_traintrack_index = len(list_of_tracks)
                list_of_tracks.append(T_ROL)
                we_added_new_traintracks = True  # Set to True since a new track is added
                # AutomotonGraph.add_edges(list_of_tracks.index(j),added_traintrack_index, f"{ROL_standardizing_braid}")
                AutomatonGraph.add_vertices([list_of_tracks.index(j),added_traintrack_index])
                AutomatonGraph.add_edge((list_of_tracks.index(j),added_traintrack_index))
                cusp_dictionary[added_traintrack_index] = T_ROL.cusps
                number_of_traintrack_counter += _sage_const_1 
            else:
                existing_traintrack_index = is_traintrack_in_list(T_ROL, list_of_tracks)[_sage_const_1 ]
                # AutomotonGraph.add_edges(existing_traintrack_index,existing_traintrack_index, f"{ROL_standardizing_braid}")
                # if (existing_traintrack_index, existing_traintrack_index) not in list_of_tracks[existing_traintrack_index].graph.edges():
                AutomatonGraph.add_vertices([existing_traintrack_index,existing_traintrack_index])
                AutomatonGraph.add_edge((existing_traintrack_index,existing_traintrack_index))

            if not is_traintrack_in_list(T_LOR, list_of_tracks)[_sage_const_0 ]:
                added_traintrack_index = len(list_of_tracks)
                list_of_tracks.append(T_LOR)
                we_added_new_traintracks = True  # Set to True since a new track is added
                AutomatonGraph.add_vertices([list_of_tracks.index(j),added_traintrack_index])
                AutomatonGraph.add_edge((list_of_tracks.index(j),added_traintrack_index))
                cusp_dictionary[added_traintrack_index] = T_LOR.cusps
                number_of_traintrack_counter += _sage_const_1 
            else:
                existing_traintrack_index = is_traintrack_in_list(T_LOR, list_of_tracks)[_sage_const_1 ]
                # AutomotonGraph.add_edges(existing_traintrack_index,existing_traintrack_index, f"{ROL_standardizing_braid}")
                # if (existing_traintrack_index, existing_traintrack_index) not in list_of_tracks[existing_traintrack_index].graph.edges():
                AutomatonGraph.add_vertices([existing_traintrack_index,existing_traintrack_index])
                AutomatonGraph.add_edge((existing_traintrack_index,existing_traintrack_index))
            index_of_cusp += _sage_const_1 

    print(f'i is {i} and j is {j}')
    print(f'we_added_new_traintracks is {we_added_new_traintracks}')

AutomatonGraph.set_vertices(AutomatonDict)
# If we reach here without setting we_added_new_traintracks to True, then no new tracks were added
# and we will exit the loop
        

